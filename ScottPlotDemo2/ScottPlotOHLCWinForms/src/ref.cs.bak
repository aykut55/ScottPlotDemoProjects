using ScottPlot;
using ScottPlot.WinForms;
using System;
using System.Drawing;
using System.Windows.Forms;
using System.Linq;

namespace ScottPlotOHLCWinForms2
{
    public class GuiManager2 : IDisposable
    {
        private Form _parentForm;
        private FormsPlot _formsPlot;
        private RadioButton _rbFullData;
        private RadioButton _rbFitToScreen;
        private RadioButton _rbLastN;
        private RadioButton _rbFirstN;
        private RadioButton _rbRange;
        private TextBox _txtN;
        private TextBox _txtRangeStart;
        private TextBox _txtRangeEnd;
        private Button _btnApply;
        private RadioButton _rbReset;

        private bool _autoScaleY = true; // Flag to enable/disable automatic Y-axis scaling

        // Scrollbars
        private HScrollBar _hScrollBar;
        private VScrollBar _vScrollBar;
        private bool _isUpdatingScrollBars = false; // Prevent recursive updates

        // Global Data Limits
        private double _globalYMin = 0;
        private double _globalYMax = 100;
        private const int Y_SCROLL_RESOLUTION = 10000;

        public GuiManager2(Form parentForm)
        {
            _parentForm = parentForm;
        }

        public void Initialize()
        {
            // Create a container panel for plot and scrollbars
            Panel plotContainer = new Panel
            {
                Dock = DockStyle.Fill
            };
            _parentForm.Controls.Add(plotContainer);

            // Initialize FormsPlot - fills the container
            _formsPlot = new FormsPlot() { Dock = DockStyle.Fill };
            plotContainer.Controls.Add(_formsPlot);

            // Initialize VScrollBar - docked to right, standard width
            _vScrollBar = new VScrollBar
            {
                Dock = DockStyle.Right,
                Minimum = 0,
                Maximum = 10000,
                SmallChange = 1,
                LargeChange = 1000
            };
            plotContainer.Controls.Add(_vScrollBar);

            // Initialize HScrollBar - docked to bottom, standard height
            _hScrollBar = new HScrollBar
            {
                Dock = DockStyle.Bottom,
                Minimum = 0,
                Maximum = 10000,
                SmallChange = 1,
                LargeChange = 1000
            };
            plotContainer.Controls.Add(_hScrollBar);

            // Scrollbar Events
            _hScrollBar.Scroll += (s, e) => OnHScroll();
            _vScrollBar.Scroll += (s, e) => OnVScroll();

            // Create control panel last (will dock to top)
            _controlPanel = new Panel
            {
                Dock = DockStyle.Top,
                Height = 80,
                BackColor = System.Drawing.Color.LightGray
            };
            _parentForm.Controls.Add(_controlPanel);

            // Row 1: Radio buttons
            _rbLastFit = new RadioButton { Text = "Last Fit", Location = new Point(10, 10), AutoSize = true, Checked = true };
            _rbFullData = new RadioButton { Text = "Full Data", Location = new Point(100, 10), AutoSize = true };
            _rbFitToScreen = new RadioButton { Text = "Fit to Screen", Location = new Point(200, 10), AutoSize = true };
            _rbLastN = new RadioButton { Text = "Last N:", Location = new Point(330, 10), AutoSize = true };
            _rbFirstN = new RadioButton { Text = "First N:", Location = new Point(430, 10), AutoSize = true };
            _rbRange = new RadioButton { Text = "Range:", Location = new Point(530, 10), AutoSize = true };
            _rbReset = new RadioButton { Text = "Reset", Location = new Point(630, 10), AutoSize = true };

            _controlPanel.Controls.Add(_rbLastFit);
            _controlPanel.Controls.Add(_rbFullData);
            _controlPanel.Controls.Add(_rbFitToScreen);
            _controlPanel.Controls.Add(_rbLastN);
            _controlPanel.Controls.Add(_rbFirstN);
            _controlPanel.Controls.Add(_rbRange);
            _controlPanel.Controls.Add(_rbReset);

            // Row 2: Input controls
            _txtN = new TextBox { Location = new Point(250, 40), Width = 80, Text = "1000" };
            _txtRangeStart = new TextBox { Location = new Point(450, 40), Width = 80, Text = "0", PlaceholderText = "Start" };
            _txtRangeEnd = new TextBox { Location = new Point(540, 40), Width = 80, Text = "1000", PlaceholderText = "End" };
            _btnApply = new Button { Text = "Apply", Location = new Point(640, 38), Width = 80 };

            _controlPanel.Controls.Add(_txtN);
            _controlPanel.Controls.Add(_txtRangeStart);
            _controlPanel.Controls.Add(_txtRangeEnd);
            _controlPanel.Controls.Add(_btnApply);

            // Apply button click handler
            _btnApply.Click += (s, e) => ApplyViewMode();

            // Setup Multiplot
            _customLayout = new ScottPlot.MultiplotLayouts.DraggableRows();
            _formsPlot.Multiplot.Layout = _customLayout;

            // Setup Draggable Logic
            _formsPlot.MouseDown += (s, e) =>
            {
                _dividerBeingDragged = _customLayout.GetDivider(e.Y);
                _formsPlot.UserInputProcessor.IsEnabled = _dividerBeingDragged is null;

                // Detect Y-axis pan to disable auto-scaling (only if not dragging divider)
                if (_dividerBeingDragged is null && _mainPlot != null)
                {
                    // Store initial Y limits for pan detection
                }
            };

            _formsPlot.MouseUp += (s, e) =>
            {
                if (_dividerBeingDragged is not null)
                {
                    _dividerBeingDragged = null;
                    _formsPlot.UserInputProcessor.IsEnabled = true;
                }
                else
                {
                    // Check for manual pan (simplified for now)
                }
            };

            _formsPlot.MouseMove += (s, e) =>
            {
                if (_dividerBeingDragged is not null)
                {
                    _customLayout.SetDivider(_dividerBeingDragged.Value, e.Y);
                    _formsPlot.Refresh();
                }

                System.Windows.Forms.Cursor.Current = _customLayout.GetDivider(e.Y) is not null ? Cursors.SizeNS : Cursors.Default;

                // Crosshair update
                if (!_isUpdatingScrollBars && !_parentForm.IsDisposed)
                {
                    _parentForm.BeginInvoke((MethodInvoker)UpdateScrollBarsFromPlot);
                }
            };

            // Use the default plot as the main plot
            var plots = _formsPlot.Multiplot.GetPlots().ToArray();
            if (plots.Length > 0)
            {
                _mainPlot = plots[0];
            }
            else
            {
                _mainPlot = _formsPlot.Multiplot.AddPlot();
            }

            // Apply standard configuration to main plot
            _mainPlot.Axes.Left.MinimumSize = 60;
            _mainPlot.Axes.Left.MaximumSize = 60;
            _mainPlot.Axes.Right.MinimumSize = 60;
            _mainPlot.Axes.Right.MaximumSize = 60;

            // Setup Plots
            SetupMainPlot();
            SetupSMAPlot();
            SetupMACDPlot();
            SetupRSIPlot();

            _formsPlot.Multiplot.CollapseVertically();

            // LOD Logic
            _formsPlot.Plot.RenderManager.RenderStarting += (s, e) =>
            {
                UpdateLOD();
            };

            _formsPlot.Refresh();
        }

        public Plot AddPlot()
        {
            Plot plot = _formsPlot.Multiplot.AddPlot();
            
            // Standardize axes sizes for alignment
            plot.Axes.Left.MinimumSize = 60;
            plot.Axes.Left.MaximumSize = 60;
            plot.Axes.Right.MinimumSize = 60;
            plot.Axes.Right.MaximumSize = 60;
            
            _formsPlot.Multiplot.CollapseVertically();
            _formsPlot.Refresh();
            
            return plot;
        }

        private void SetupMainPlot()
        {
            int pointCount = 2_000_000;
            _fullData = GenerateOHLCs(pointCount);

            // Pre-calculate LOD layers
            _dataL1 = AggregateData(_fullData, 100);   // 20k points
            _dataL2 = AggregateData(_fullData, 1000);  // 2k points
            _dataL3 = AggregateData(_fullData, 10000); // 200 points
            _dataL4 = AggregateData(_fullData, 10);    // 200k points

            // Add ALL plots initially, but hide them
            // Layer 3 (Very Coarse - extreme zoom out)
            _plotL3 = _mainPlot.Add.Candlestick(_dataL3);
            _plotL3.Sequential = false;
            _plotL3.IsVisible = true; // Start visible

            // Layer 2 (Coarse)
            _plotL2 = _mainPlot.Add.Candlestick(_dataL2);
            _plotL2.Sequential = false;
            _plotL2.IsVisible = false;

            // Layer 1 (Medium)
            _plotL1 = _mainPlot.Add.Candlestick(_dataL1);
            _plotL1.Sequential = false;
            _plotL1.IsVisible = false;

            // Layer 4 (Fine - between L1 and L0)
            _plotL4 = _mainPlot.Add.Candlestick(_dataL4);
            _plotL4.Sequential = false;
            _plotL4.IsVisible = false;

            // Layer 0 (Full)
            _plotL0 = _mainPlot.Add.Candlestick(_fullData);
            _plotL0.Sequential = true; // Enable Sequential for full data
            _plotL0.IsVisible = false;

            _currentLayer = 3;

            // Mouse wheel zoom is already enabled by default for X axis
            // Left-click drag for pan is already enabled
            // We just need to add Ctrl+Wheel for Y axis zoom

            bool isCtrlPressed = false;

            _parentForm.KeyDown += (s, e) =>
            {
                if (e.KeyCode == Keys.ControlKey)
                    isCtrlPressed = true;
            };

            _parentForm.KeyUp += (s, e) =>
            {
                if (e.KeyCode == Keys.ControlKey)
                    isCtrlPressed = false;
            };

            // Custom Axis Formatter: Index -> Date (Dynamic format based on zoom level)
            ScottPlot.TickGenerators.NumericAutomatic tickGen = new ScottPlot.TickGenerators.NumericAutomatic();
            tickGen.LabelFormatter = (x) =>
            {
                int index = (int)x;
                if (index < 0 || index >= _fullData.Length) return "";

                // Get current visible range to determine appropriate format
                var axis = _mainPlot.Axes.Bottom;
                double visibleRange = axis.Max - axis.Min;

                DateTime dt = _fullData[index].DateTime;

                // Dynamic format based on visible range
                if (visibleRange > 1440) // More than 1 day
                {
                    return dt.ToString("yyyy.MM.dd");
                }
                else // Intraday - show time too
                {
                    return dt.ToString("yyyy.MM.dd HH:mm:ss");
                }
            };
            _mainPlot.Axes.Bottom.TickGenerator = tickGen;

            // Detect Y-axis pan to disable auto-scaling
            double lastYMin = 0;
            double lastYMax = 0;

            _formsPlot.MouseDown += (s, e) =>
            {
                // Only track if we are interacting with the main plot
                // Ideally check bounds, but for now simple check
                lastYMin = _mainPlot.Axes.Left.Min;
                lastYMax = _mainPlot.Axes.Left.Max;
            };

            _formsPlot.MouseUp += (s, e) =>
            {
                // Check if Y-axis changed (user panned Y-axis)
                double currentYMin = _mainPlot.Axes.Left.Min;
                double currentYMax = _mainPlot.Axes.Left.Max;

                if (Math.Abs(currentYMin - lastYMin) > 0.001 || Math.Abs(currentYMax - lastYMax) > 0.001)
                {
                    // Y-axis was manually changed, disable auto-scaling
                    _autoScaleY = false;
                    System.Diagnostics.Debug.WriteLine("[Y-Axis] Manual pan detected, auto-scaling disabled");
                }
            };

            // Add Crosshair
            var crosshair = _mainPlot.Add.Crosshair(0, 0);
            crosshair.IsVisible = false;

            _formsPlot.MouseMove += (s, e) =>
            {
                if (_fullData == null) return; // Wait for data

                // Only show crosshair if over main plot? 
                // Or show across all?
                // For now, keep simple
                if (!crosshair.IsVisible) crosshair.IsVisible = true;
                var mouse = _mainPlot.GetCoordinates(e.X, e.Y);
                crosshair.X = mouse.X;
                crosshair.Y = mouse.Y;
                // _formsPlot.Refresh(); // Refresh handled by draggable logic or timer? 
                // Frequent refresh might be heavy with multiplot.
                // Let's rely on the draggable refresh or add a check.
                if (_dividerBeingDragged == null) _formsPlot.Refresh();
            };

            _mainPlot.Title($"OHLC Chart with {pointCount:N0} Points (LOD)");

            // Initial Scrollbar Update
            UpdateScrollBarsFromPlot();
        }

        private void SetupSMAPlot()
        {
            var smaPlot = AddPlot();
            smaPlot.Axes.Right.Label.Text = "SMA";

            // Calculate SMA for all layers
            double[] sma20L0 = IndicatorManager.CalculateSMA(_fullData, 20);
            double[] sma50L0 = IndicatorManager.CalculateSMA(_fullData, 50);

            double[] sma20L1 = IndicatorManager.CalculateSMA(_dataL1, 20);
            double[] sma50L1 = IndicatorManager.CalculateSMA(_dataL1, 50);

            double[] sma20L2 = IndicatorManager.CalculateSMA(_dataL2, 20);
            double[] sma50L2 = IndicatorManager.CalculateSMA(_dataL2, 50);

            double[] sma20L3 = IndicatorManager.CalculateSMA(_dataL3, 20);
            double[] sma50L3 = IndicatorManager.CalculateSMA(_dataL3, 50);

            double[] sma20L4 = IndicatorManager.CalculateSMA(_dataL4, 20);
            double[] sma50L4 = IndicatorManager.CalculateSMA(_dataL4, 50);

            // Add plots
            _sma20L0 = smaPlot.Add.Signal(sma20L0); _sma20L0.Color = Colors.Blue; _sma20L0.LegendText = "SMA 20"; _sma20L0.IsVisible = false;
            _sma50L0 = smaPlot.Add.Signal(sma50L0); _sma50L0.Color = Colors.Orange; _sma50L0.LegendText = "SMA 50"; _sma50L0.IsVisible = false;

            _sma20L1 = smaPlot.Add.Signal(sma20L1); _sma20L1.Color = Colors.Blue; _sma20L1.IsVisible = false;
            _sma50L1 = smaPlot.Add.Signal(sma50L1); _sma50L1.Color = Colors.Orange; _sma50L1.IsVisible = false;

            _sma20L2 = smaPlot.Add.Signal(sma20L2); _sma20L2.Color = Colors.Blue; _sma20L2.IsVisible = false;
            _sma50L2 = smaPlot.Add.Signal(sma50L2); _sma50L2.Color = Colors.Orange; _sma50L2.IsVisible = false;

            _sma20L3 = smaPlot.Add.Signal(sma20L3); _sma20L3.Color = Colors.Blue; _sma20L3.IsVisible = false;
            _sma50L3 = smaPlot.Add.Signal(sma50L3); _sma50L3.Color = Colors.Orange; _sma50L3.IsVisible = false;

            _sma20L4 = smaPlot.Add.Signal(sma20L4); _sma20L4.Color = Colors.Blue; _sma20L4.IsVisible = false;
            _sma50L4 = smaPlot.Add.Signal(sma50L4); _sma50L4.Color = Colors.Orange; _sma50L4.IsVisible = false;
        }

        private void SetupMACDPlot()
        {
            var macdPlot = AddPlot();
            macdPlot.Axes.Right.Label.Text = "MACD";

            // Calculate MACD for all layers
            var macdL0 = IndicatorManager.CalculateMACD(_fullData);
            var macdL1 = IndicatorManager.CalculateMACD(_dataL1);
            var macdL2 = IndicatorManager.CalculateMACD(_dataL2);
            var macdL3 = IndicatorManager.CalculateMACD(_dataL3);
            var macdL4 = IndicatorManager.CalculateMACD(_dataL4);

            // Add plots
            // L0
            _macdLineL0 = macdPlot.Add.Signal(macdL0.macdLine); _macdLineL0.Color = Colors.Blue; _macdLineL0.LegendText = "MACD"; _macdLineL0.IsVisible = false;
            _signalLineL0 = macdPlot.Add.Signal(macdL0.signalLine); _signalLineL0.Color = Colors.Orange; _signalLineL0.LegendText = "Signal"; _signalLineL0.IsVisible = false;
            _histogramL0 = macdPlot.Add.Bars(macdL0.histogram); _histogramL0.Color = Colors.Gray; _histogramL0.LegendText = "Histogram"; _histogramL0.IsVisible = false;

            // L1
            _macdLineL1 = macdPlot.Add.Signal(macdL1.macdLine); _macdLineL1.Color = Colors.Blue; _macdLineL1.IsVisible = false;
            _signalLineL1 = macdPlot.Add.Signal(macdL1.signalLine); _signalLineL1.Color = Colors.Orange; _signalLineL1.IsVisible = false;
            _histogramL1 = macdPlot.Add.Bars(macdL1.histogram); _histogramL1.Color = Colors.Gray; _histogramL1.IsVisible = false;

            // L2
            _macdLineL2 = macdPlot.Add.Signal(macdL2.macdLine); _macdLineL2.Color = Colors.Blue; _macdLineL2.IsVisible = false;
            _signalLineL2 = macdPlot.Add.Signal(macdL2.signalLine); _signalLineL2.Color = Colors.Orange; _signalLineL2.IsVisible = false;
            _histogramL2 = macdPlot.Add.Bars(macdL2.histogram); _histogramL2.Color = Colors.Gray; _histogramL2.IsVisible = false;

            // L3
            _macdLineL3 = macdPlot.Add.Signal(macdL3.macdLine); _macdLineL3.Color = Colors.Blue; _macdLineL3.IsVisible = false;
            _signalLineL3 = macdPlot.Add.Signal(macdL3.signalLine); _signalLineL3.Color = Colors.Orange; _signalLineL3.IsVisible = false;
            _histogramL3 = macdPlot.Add.Bars(macdL3.histogram); _histogramL3.Color = Colors.Gray; _histogramL3.IsVisible = false;

            // L4
            _macdLineL4 = macdPlot.Add.Signal(macdL4.macdLine); _macdLineL4.Color = Colors.Blue; _macdLineL4.IsVisible = false;
            _signalLineL4 = macdPlot.Add.Signal(macdL4.signalLine); _signalLineL4.Color = Colors.Orange; _signalLineL4.IsVisible = false;
            _histogramL4 = macdPlot.Add.Bars(macdL4.histogram); _histogramL4.Color = Colors.Gray; _histogramL4.IsVisible = false;
        }

        private void SetupRSIPlot()
        {
            var rsiPlot = AddPlot();
            rsiPlot.Axes.Right.Label.Text = "RSI";
            rsiPlot.Axes.SetLimitsY(0, 100);
            rsiPlot.Add.HorizontalLine(30, 1, Colors.Gray, LinePattern.Dashed);
            rsiPlot.Add.HorizontalLine(70, 1, Colors.Gray, LinePattern.Dashed);

            // Calculate RSI for all layers
            double[] rsiL0 = IndicatorManager.CalculateRSI(_fullData);
            double[] rsiL1 = IndicatorManager.CalculateRSI(_dataL1);
            double[] rsiL2 = IndicatorManager.CalculateRSI(_dataL2);
            double[] rsiL3 = IndicatorManager.CalculateRSI(_dataL3);
            double[] rsiL4 = IndicatorManager.CalculateRSI(_dataL4);

            // Add plots
            _rsiL0 = rsiPlot.Add.Signal(rsiL0); _rsiL0.Color = Colors.Purple; _rsiL0.LegendText = "RSI"; _rsiL0.IsVisible = false;
            _rsiL1 = rsiPlot.Add.Signal(rsiL1); _rsiL1.Color = Colors.Purple; _rsiL1.IsVisible = false;
            _rsiL2 = rsiPlot.Add.Signal(rsiL2); _rsiL2.Color = Colors.Purple; _rsiL2.IsVisible = false;
            _rsiL3 = rsiPlot.Add.Signal(rsiL3); _rsiL3.Color = Colors.Purple; _rsiL3.IsVisible = false;
            _rsiL4 = rsiPlot.Add.Signal(rsiL4); _rsiL4.Color = Colors.Purple; _rsiL4.IsVisible = false;
        }

        private void UpdateLOD()
        {
            try
            {
                if (_fullData == null || _mainPlot == null) return;

                var axis = _mainPlot.Axes.Bottom;
                double range = axis.Max - axis.Min;

                // Decide which layer to use based on visible range (zoom level)
                int targetLayer = _currentLayer;

                if (range > 1_000_000)
                {
                    targetLayer = 3; // 200 points
                }
                else if (range > 500_000)
                {
                    targetLayer = 2; // 2k points
                }
                else if (range > 20_000)
                {
                    targetLayer = 1; // 20k points
                }
                else if (range > 2_000)
                {
                    targetLayer = 4; // 200k points
                }
                else
                {
                    targetLayer = 0; // 2M points (full)
                }

                // Only switch if changed
                if (targetLayer != _currentLayer)
                {
                    System.Diagnostics.Debug.WriteLine($"[LOD Switch] Range: {range:N0} -> Switching to Layer {targetLayer}");

                    // OHLC Visibility
                    _plotL0.IsVisible = (targetLayer == 0);
                    _plotL1.IsVisible = (targetLayer == 1);
                    _plotL2.IsVisible = (targetLayer == 2);
                    _plotL3.IsVisible = (targetLayer == 3);
                    _plotL4.IsVisible = (targetLayer == 4);

                    // SMA Visibility
                    if (_sma20L0 != null)
                    {
                        _sma20L0.IsVisible = (targetLayer == 0); _sma50L0.IsVisible = (targetLayer == 0);
                        _sma20L1.IsVisible = (targetLayer == 1); _sma50L1.IsVisible = (targetLayer == 1);
                        _sma20L2.IsVisible = (targetLayer == 2); _sma50L2.IsVisible = (targetLayer == 2);
                        _sma20L3.IsVisible = (targetLayer == 3); _sma50L3.IsVisible = (targetLayer == 3);
                        _sma20L4.IsVisible = (targetLayer == 4); _sma50L4.IsVisible = (targetLayer == 4);
                    }

                    // MACD Visibility
                    if (_macdLineL0 != null)
                    {
                        _macdLineL0.IsVisible = (targetLayer == 0); _signalLineL0.IsVisible = (targetLayer == 0); _histogramL0.IsVisible = (targetLayer == 0);
                        _macdLineL1.IsVisible = (targetLayer == 1); _signalLineL1.IsVisible = (targetLayer == 1); _histogramL1.IsVisible = (targetLayer == 1);
                        _macdLineL2.IsVisible = (targetLayer == 2); _signalLineL2.IsVisible = (targetLayer == 2); _histogramL2.IsVisible = (targetLayer == 2);
                        _macdLineL3.IsVisible = (targetLayer == 3); _signalLineL3.IsVisible = (targetLayer == 3); _histogramL3.IsVisible = (targetLayer == 3);
                        _macdLineL4.IsVisible = (targetLayer == 4); _signalLineL4.IsVisible = (targetLayer == 4); _histogramL4.IsVisible = (targetLayer == 4);
                    }

                    // RSI Visibility
                    if (_rsiL0 != null)
                    {
                        _rsiL0.IsVisible = (targetLayer == 0);
                        _rsiL1.IsVisible = (targetLayer == 1);
                        _rsiL2.IsVisible = (targetLayer == 2);
                        _rsiL3.IsVisible = (targetLayer == 3);
                        _rsiL4.IsVisible = (targetLayer == 4);
                    }

                    _currentLayer = targetLayer;
                }

                // Update Title with aggregation info
                int displayedCount = 0;
                string aggInfo = "";
                int logicalLayer = 0; // Logical layer number based on zoom level

                if (_currentLayer == 0)
                {
                    displayedCount = _fullData.Length;
                    aggInfo = "Full Data";
                    logicalLayer = 0; // Most zoomed in
                }
                else if (_currentLayer == 4)
                {
                    displayedCount = _dataL4.Length;
                    aggInfo = "x10";
                    logicalLayer = 1;
                }
                else if (_currentLayer == 1)
                {
                    displayedCount = _dataL1.Length;
                    aggInfo = "x100";
                    logicalLayer = 2;
                }
                else if (_currentLayer == 2)
                {
                    displayedCount = _dataL2.Length;
                    aggInfo = "x1000";
                    logicalLayer = 3;
                }
                else // _currentLayer == 3
                {
                    displayedCount = _dataL3.Length;
                    aggInfo = "x10000";
                    logicalLayer = 4; // Most zoomed out
                }

                _mainPlot.Title($"Total: {_fullData.Length:N0} | Showing: {displayedCount:N0} ({aggInfo}) | Layer: {logicalLayer}");

                // Auto-scale Y axis based on visible X range (only if auto-scaling is enabled)
                if (_autoScaleY)
                {
                    var xAxis = _mainPlot.Axes.Bottom;
                    int visibleStartIdx = Math.Max(0, (int)Math.Floor(xAxis.Min));
                    int visibleEndIdx = Math.Min(_fullData.Length, (int)Math.Ceiling(xAxis.Max));

                    if (visibleStartIdx < visibleEndIdx && visibleEndIdx <= _fullData.Length)
                    {
                        double yMin = double.MaxValue;
                        double yMax = double.MinValue;

                        for (int i = visibleStartIdx; i < visibleEndIdx; i++)
                        {
                            yMin = Math.Min(yMin, _fullData[i].Low);
                            yMax = Math.Max(yMax, _fullData[i].High);
                        }

                        if (yMin < yMax)
                        {
                            // Add 5% padding to Y limits
                            double yPadding = (yMax - yMin) * 0.05;
                            _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"[CRASH] RenderStarting: {ex.Message}");
            }
        }

        private void OnHScroll()
        {
            if (_isUpdatingScrollBars || _fullData == null || _mainPlot == null) return;

            try
            {
                _isUpdatingScrollBars = true;

                int maxScroll = _hScrollBar.Maximum - _hScrollBar.LargeChange + 1;
                double scrollRatio = (double)_hScrollBar.Value / maxScroll;

                var xAxis = _mainPlot.Axes.Bottom;
                double currentSpan = xAxis.Max - xAxis.Min;

                // Total data range
                double totalMin = 0;
                double totalMax = _fullData.Length;
                double totalSpan = totalMax - totalMin;

                // Calculate new center based on scroll ratio
                double newMin = totalMin + (scrollRatio * (totalSpan - currentSpan));
                double newMax = newMin + currentSpan;

                _mainPlot.Axes.SetLimitsX(newMin, newMax);

                // Auto-scale Y axis if enabled
                if (_autoScaleY)
                {
                    // Logic handled in RenderStarting (UpdateLOD)
                }

                _formsPlot.Refresh();
            }
            finally
            {
                _isUpdatingScrollBars = false;
            }
        }

        private void OnVScroll()
        {
            if (_isUpdatingScrollBars || _fullData == null || _mainPlot == null) return;

            try
            {
                _isUpdatingScrollBars = true;

                // Disable auto-scale when user manually scrolls Y-axis
                _autoScaleY = false;

                // Invert Y scrollbar because 0 is at top in WinForms but Y-axis Max is at top
                int maxScroll = _vScrollBar.Maximum - _vScrollBar.LargeChange + 1;
                int invertedValue = maxScroll - _vScrollBar.Value;
                double scrollRatio = (double)invertedValue / maxScroll;

                var yAxis = _mainPlot.Axes.Left;
                double currentSpan = yAxis.Max - yAxis.Min;

                // For Y-axis, we need to determine a "Total Range". 
                double globalYMin = _globalYMin;
                double globalYMax = _globalYMax;

                double totalSpan = globalYMax - globalYMin;

                // Apply scroll
                double newMin = globalYMin + (scrollRatio * (totalSpan - currentSpan));
                double newMax = newMin + currentSpan;

                _mainPlot.Axes.SetLimitsY(newMin, newMax);
                _formsPlot.Refresh();
            }
            finally
            {
                _isUpdatingScrollBars = false;
            }
        }

        private void UpdateScrollBarsFromPlot()
        {
            if (_isUpdatingScrollBars || _fullData == null || _mainPlot == null) return;

            try
            {
                _isUpdatingScrollBars = true;

                // Update HScrollBar (X-Axis)
                var xAxis = _mainPlot.Axes.Bottom;
                double xMin = xAxis.Min;
                double xMax = xAxis.Max;
                double xSpan = xMax - xMin;
                double totalXSpan = _fullData.Length;

                if (totalXSpan > 0)
                {
                    // Calculate proportion of visible area
                    double viewRatio = xSpan / totalXSpan;
                    int newLargeChange = (int)(viewRatio * _hScrollBar.Maximum);
                    newLargeChange = Math.Max(1, Math.Min(_hScrollBar.Maximum, newLargeChange));

                    _hScrollBar.LargeChange = newLargeChange;

                    // Calculate position
                    double posRatio = xMin / totalXSpan;
                    int newValue = (int)(posRatio * _hScrollBar.Maximum);
                    newValue = Math.Max(_hScrollBar.Minimum, Math.Min(_hScrollBar.Maximum - newLargeChange + 1, newValue));

                    _hScrollBar.Value = newValue;
                }

                // Update VScrollBar (Y-Axis)
                var yAxis = _mainPlot.Axes.Left;
                double yMin = yAxis.Min;
                double yMax = yAxis.Max;
                double ySpan = yMax - yMin;

                double globalYMin = _globalYMin;
                double globalYMax = _globalYMax;

                double totalYSpan = globalYMax - globalYMin;

                if (totalYSpan > 0)
                {
                    double viewRatio = ySpan / totalYSpan;
                    int newLargeChange = (int)(viewRatio * _vScrollBar.Maximum);
                    newLargeChange = Math.Max(1, Math.Min(_vScrollBar.Maximum, newLargeChange));

                    _vScrollBar.LargeChange = newLargeChange;

                    // Position (Inverted for WinForms VScrollBar)
                    double distFromMin = yMin - globalYMin;
                    double posRatio = distFromMin / totalYSpan;

                    // Invert
                    int maxScroll = _vScrollBar.Maximum - newLargeChange + 1;
                    int newValue = maxScroll - (int)(posRatio * maxScroll);

                    newValue = Math.Max(_vScrollBar.Minimum, Math.Min(maxScroll, newValue));

                    _vScrollBar.Value = newValue;

                    // Enable/disable based on whether we can scroll
                    _vScrollBar.Enabled = (newLargeChange < _vScrollBar.Maximum);
                }
            }
            catch
            {
                // Ignore errors during update
            }
            finally
            {
                _isUpdatingScrollBars = false;
            }
        }

        private OHLC[] GenerateOHLCs(int count)
        {
            System.Diagnostics.Debug.WriteLine($"[GenerateOHLCs] Starting generation of {count:N0} points...");
            var sw = System.Diagnostics.Stopwatch.StartNew();

            OHLC[] ohlcs = new OHLC[count];
            DateTime startDate = new DateTime(2020, 1, 1);
            double open = 100;
            Random rand = new Random(0);

            for (int i = 0; i < count; i++)
            {
                double change = (rand.NextDouble() - 0.5) * 2;
                double close = open + change;
                double high = Math.Max(open, close) + rand.NextDouble();
                double low = Math.Min(open, close) - rand.NextDouble();

                high = Math.Max(high, Math.Max(open, close));
                low = Math.Min(low, Math.Min(open, close));

                TimeSpan timeSpan = TimeSpan.FromMinutes(1);
                DateTime time = startDate + (timeSpan * i);

                // Use real time for proper date display on X-axis
                ohlcs[i] = new OHLC(open, high, low, close, time, timeSpan);
                open = close;
            }

            // Calculate Global Y Limits
            _globalYMin = double.MaxValue;
            _globalYMax = double.MinValue;
            foreach (var o in ohlcs)
            {
                if (o.Low < _globalYMin) _globalYMin = o.Low;
                if (o.High > _globalYMax) _globalYMax = o.High;
            }
            // Add some padding to global limits
            double padding = (_globalYMax - _globalYMin) * 0.05;
            _globalYMin -= padding;
            _globalYMax += padding;

            sw.Stop();
            System.Diagnostics.Debug.WriteLine($"[GenerateOHLCs] Completed in {sw.ElapsedMilliseconds}ms");
            return ohlcs;
        }

        private OHLC[] AggregateData(OHLC[] source, int factor)
        {
            System.Diagnostics.Debug.WriteLine($"[AggregateData] Aggregating factor {factor}...");
            var sw = System.Diagnostics.Stopwatch.StartNew();

            int newCount = source.Length / factor;
            OHLC[] result = new OHLC[newCount];

            for (int i = 0; i < newCount; i++)
            {
                int baseIdx = i * factor;
                double o = source[baseIdx].Open;
                double c = source[baseIdx + factor - 1].Close;
                double h = double.MinValue;
                double l = double.MaxValue;

                for (int j = 0; j < factor; j++)
                {
                    h = Math.Max(h, source[baseIdx + j].High);
                    l = Math.Min(l, source[baseIdx + j].Low);
                }

                // X coordinate should be the center or start?
                // Let's use center to align nicely.
                // Center index = baseIdx + factor / 2.0
                double centerIndex = baseIdx + (factor / 2.0);

                result[i] = new OHLC(o, h, l, c, DateTime.FromOADate(centerIndex), TimeSpan.FromDays(factor));
            }

            sw.Stop();
            System.Diagnostics.Debug.WriteLine($"[AggregateData] Completed in {sw.ElapsedMilliseconds}ms. New count: {newCount:N0}");
            return result;
        }

        /// <summary>
        /// Calculates how many candlesticks can fit on the screen based on plot width.
        /// Each candlestick needs minimum space for body + wicks + spacing.
        /// </summary>
        private int CalculateFitToScreenCount()
        {
            try
            {
                // Get the plot area width in pixels
                var plotArea = _formsPlot.Plot.RenderManager.LastRender.DataRect;
                double plotWidthPixels = plotArea.Width;

                // Minimum pixels per candlestick (body + spacing)
                // Typical candlestick needs ~5-10 pixels to be readable
                // We'll use 8 pixels as a good balance
                const double minPixelsPerCandle = 8.0;

                // Calculate how many candlesticks can fit
                int count = (int)(plotWidthPixels / minPixelsPerCandle);

                // Ensure we have at least 50 and at most 2000 candlesticks
                count = Math.Max(50, Math.Min(2000, count));

                System.Diagnostics.Debug.WriteLine($"[FitToScreen] Plot width: {plotWidthPixels}px, Calculated count: {count}");

                return count;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"[FitToScreen] Error calculating count: {ex.Message}");
                // Fallback to 500 if calculation fails
                return 500;
            }
        }

        private void ApplyViewMode()
        {
            if (_fullData == null || _mainPlot == null) return;

            int totalCount = _fullData.Length;

            // Re-enable auto Y-scaling when applying a view mode
            _autoScaleY = true;

            try
            {
                if (_rbLastFit.Checked)
                {
                    // Show last N bars that fit on screen
                    int visibleCount = CalculateFitToScreenCount();
                    int startIdx = Math.Max(0, totalCount - visibleCount);
                    int endIdx = totalCount;

                    // Add 2% padding to X-axis
                    double xRange = endIdx - startIdx;
                    double xPadding = xRange * 0.02;
                    _mainPlot.Axes.SetLimitsX(startIdx - xPadding, endIdx + xPadding);

                    // Calculate Y limits from visible data
                    double yMin = double.MaxValue;
                    double yMax = double.MinValue;
                    for (int i = startIdx; i < endIdx && i < _fullData.Length; i++)
                    {
                        yMin = Math.Min(yMin, _fullData[i].Low);
                        yMax = Math.Max(yMax, _fullData[i].High);
                    }

                    // Add 5% padding to Y limits
                    double yPadding = (yMax - yMin) * 0.05;
                    _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                    _formsPlot.Refresh();
                }
                else if (_rbReset.Checked || _rbFullData.Checked)
                {
                    // Show all data, let LOD decide which layer
                    // Add 2% padding to X-axis
                    double xPadding = totalCount * 0.02;
                    _mainPlot.Axes.SetLimitsX(-xPadding, totalCount + xPadding);

                    // Calculate Y limits from all data
                    double yMin = double.MaxValue;
                    double yMax = double.MinValue;
                    for (int i = 0; i < _fullData.Length; i++)
                    {
                        yMin = Math.Min(yMin, _fullData[i].Low);
                        yMax = Math.Max(yMax, _fullData[i].High);
                    }

                    // Add 5% padding to Y limits
                    double yPadding = (yMax - yMin) * 0.05;
                    _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                    _formsPlot.Refresh();
                }
                else if (_rbFitToScreen.Checked)
                {
                    // Get current X-axis limits
                    var xAxis = _mainPlot.Axes.Bottom;
                    double currentXMin = xAxis.Min;
                    double currentXMax = xAxis.Max;
                    double currentXRange = currentXMax - currentXMin;

                    // Check if user has a custom view (zoomed/panned) or if showing full data
                    bool isFullDataView = (currentXMin <= 0 && currentXMax >= totalCount - 1);

                    if (isFullDataView)
                    {
                        // Coming from Full Data/Reset - fit X-axis to show last N bars
                        int visibleCount = CalculateFitToScreenCount();
                        int startIdx = Math.Max(0, totalCount - visibleCount);
                        int endIdx = totalCount;

                        // Add 2% padding to X-axis
                        double xRange = endIdx - startIdx;
                        double xPadding = xRange * 0.02;
                        _mainPlot.Axes.SetLimitsX(startIdx - xPadding, endIdx + xPadding);

                        // Calculate Y limits from visible data
                        double yMin = double.MaxValue;
                        double yMax = double.MinValue;
                        for (int i = startIdx; i < endIdx && i < _fullData.Length; i++)
                        {
                            yMin = Math.Min(yMin, _fullData[i].Low);
                            yMax = Math.Max(yMax, _fullData[i].High);
                        }

                        // Add 5% padding to Y limits
                        double yPadding = (yMax - yMin) * 0.05;
                        _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                        System.Diagnostics.Debug.WriteLine($"[FitToScreen] Full data view - showing range: {startIdx} to {endIdx} ({visibleCount} bars), Y: {yMin:F2} to {yMax:F2}");
                    }
                    else
                    {
                        // User has zoomed/panned - keep X-axis, only fit Y-axis
                        int visibleStartIdx = Math.Max(0, (int)Math.Floor(currentXMin));
                        int visibleEndIdx = Math.Min(_fullData.Length, (int)Math.Ceiling(currentXMax));

                        // Calculate Y limits from currently visible data
                        double yMin = double.MaxValue;
                        double yMax = double.MinValue;
                        for (int i = visibleStartIdx; i < visibleEndIdx && i < _fullData.Length; i++)
                        {
                            yMin = Math.Min(yMin, _fullData[i].Low);
                            yMax = Math.Max(yMax, _fullData[i].High);
                        }

                        // Add 5% padding to Y limits
                        double yPadding = (yMax - yMin) * 0.05;
                        _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                        System.Diagnostics.Debug.WriteLine($"[FitToScreen] Custom view - keeping X-axis [{visibleStartIdx} to {visibleEndIdx}], fitting Y: {yMin:F2} to {yMax:F2}");
                    }

                    _formsPlot.Refresh();
                }
                else if (_rbLastN.Checked)
                {
                    // Show last N points
                    if (int.TryParse(_txtN.Text, out int n))
                    {
                        int startIdx = Math.Max(0, totalCount - n);

                        // Add 2% padding to X-axis
                        double xRange = totalCount - startIdx;
                        double xPadding = xRange * 0.02;
                        _mainPlot.Axes.SetLimitsX(startIdx - xPadding, totalCount + xPadding);

                        // Calculate Y limits from visible data
                        double yMin = double.MaxValue;
                        double yMax = double.MinValue;
                        for (int i = startIdx; i < totalCount && i < _fullData.Length; i++)
                        {
                            yMin = Math.Min(yMin, _fullData[i].Low);
                            yMax = Math.Max(yMax, _fullData[i].High);
                        }

                        // Add 5% padding to Y limits
                        double yPadding = (yMax - yMin) * 0.05;
                        _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                        _formsPlot.Refresh();
                    }
                    else
                    {
                        MessageBox.Show("Please enter a valid number for N", "Invalid Input");
                    }
                }
                else if (_rbFirstN.Checked)
                {
                    // Show first N points
                    if (int.TryParse(_txtN.Text, out int n))
                    {
                        int endIdx = Math.Min(totalCount, n);

                        // Add 2% padding to X-axis
                        double xPadding = endIdx * 0.02;
                        _mainPlot.Axes.SetLimitsX(-xPadding, endIdx + xPadding);

                        // Calculate Y limits from visible data
                        double yMin = double.MaxValue;
                        double yMax = double.MinValue;
                        for (int i = 0; i < endIdx && i < _fullData.Length; i++)
                        {
                            yMin = Math.Min(yMin, _fullData[i].Low);
                            yMax = Math.Max(yMax, _fullData[i].High);
                        }

                        // Add 5% padding to Y limits
                        double yPadding = (yMax - yMin) * 0.05;
                        _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                        _formsPlot.Refresh();
                    }
                    else
                    {
                        MessageBox.Show("Please enter a valid number for N", "Invalid Input");
                    }
                }
                else if (_rbRange.Checked)
                {
                    // Show range [start, end]
                    if (int.TryParse(_txtRangeStart.Text, out int start) &&
                        int.TryParse(_txtRangeEnd.Text, out int end))
                    {
                        start = Math.Max(0, Math.Min(start, totalCount));
                        end = Math.Max(0, Math.Min(end, totalCount));

                        if (start < end)
                        {
                            // Add 2% padding to X-axis
                            double xRange = end - start;
                            double xPadding = xRange * 0.02;
                            _mainPlot.Axes.SetLimitsX(start - xPadding, end + xPadding);

                            // Calculate Y limits from visible data
                            double yMin = double.MaxValue;
                            double yMax = double.MinValue;
                            for (int i = start; i < end && i < _fullData.Length; i++)
                            {
                                yMin = Math.Min(yMin, _fullData[i].Low);
                                yMax = Math.Max(yMax, _fullData[i].High);
                            }

                            // Add 5% padding to Y limits
                            double yPadding = (yMax - yMin) * 0.05;
                            _mainPlot.Axes.SetLimitsY(yMin - yPadding, yMax + yPadding);

                            _formsPlot.Refresh();
                        }
                        else
                        {
                            MessageBox.Show("Start must be less than End", "Invalid Range");
                        }
                    }
                    else
                    {
                        MessageBox.Show("Please enter valid numbers for Start and End", "Invalid Input");
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error applying view mode: {ex.Message}", "Error");
            }
        }

        ~GuiManager2()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                // Dispose managed resources
                _formsPlot?.Dispose();
            }
        }
    }
}